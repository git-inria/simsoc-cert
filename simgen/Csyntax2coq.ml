(**
SimSoC-Cert, a toolkit for generating certified processor simulators
See the COPYRIGHTS and LICENSE files.

Pretty print CompCert type [AST.program fundef type] to Coq.
*)

open AST;;
open Values;;
open Csyntax;;
open Datatypes;;
open Printf;;
open Camlcoq;;

(*****************************************************************************)
(** basic OCaml data structures *)

type 'a bprint = Buffer.t -> 'a -> unit;;
type 'a fprint = out_channel -> 'a -> unit;;

let fprint f oc x =
  let b = Buffer.create 100 in
    f b x; fprintf oc "%s" (Buffer.contents b);;

let sprint f x =
  let b = Buffer.create 100 in
    f b x; sprintf "%s" (Buffer.contents b);;

let string b s = bprintf b "%s" s;;
let int b i = bprintf b "%d" i;;
let int32 b i = bprintf b "%ld" i;;

let pair f sep g b (x, y) = bprintf b "%a%s%a" f x sep g y;;
let first f b (x,_) = f b x;;
let second f b (_,x) = f b x;;

let par f b x = bprintf b "(%a)" f x;;

let prefix s f b x = bprintf b "%s%a" s f x;;
let postfix s f b x = bprintf b "%a%s" f x s;;
let endline f b x = postfix "\n" f b x;;

let list_iter elt b = List.iter (elt b);;

let list sep elt =
  let rec aux b = function
    | [] -> ()
    | [x] -> elt b x
    | x :: l -> bprintf b "%a%s%a" elt x sep aux l
  in aux;;

let list_nil nil sep elt =
  let rec aux b = function
    | [] -> bprintf b "%s" nil
    | x :: l -> bprintf b "%a%s%a" elt x sep aux l
  in aux;;

let plist f b = function
  | [] -> f b []
  | l -> par f b l;;

let using string_of_elt b x = string b (string_of_elt x);;

let app1 b s f1 v1 = bprintf b "%s %a" s f1 v1;;
let app2 b s f1 v1 f2 v2 = bprintf b "%s %a %a" s f1 v1 f2 v2;;
let app3 b s f1 v1 f2 v2 f3 v3 =
  bprintf b "%s %a %a %a" s f1 v1 f2 v2 f3 v3;;
let app4 b s f1 v1 f2 v2 f3 v3 f4 v4 =
  bprintf b "%s %a %a %a %a" s f1 v1 f2 v2 f3 v3 f4 v4;;
let papp5 b s f1 v1 f2 v2 f3 v3 f4 v4 f5 v5 =
  bprintf b "%s %a %a %a %a %a" s f1 v1 f2 v2 f3 v3 f4 v4 f5 v5;;

let papp1 b s f1 v1 = bprintf b "(%s %a)" s f1 v1;;
let papp2 b s f1 v1 f2 v2 = bprintf b "(%s %a %a)" s f1 v1 f2 v2;;
let papp3 b s f1 v1 f2 v2 f3 v3 =
  bprintf b "(%s %a %a %a)" s f1 v1 f2 v2 f3 v3;;
let papp4 b s f1 v1 f2 v2 f3 v3 f4 v4 =
  bprintf b "(%s %a %a %a %a)" s f1 v1 f2 v2 f3 v3 f4 v4;;
let papp5 b s f1 v1 f2 v2 f3 v3 f4 v4 f5 v5 =
  bprintf b "(%s %a %a %a %a %a)" s f1 v1 f2 v2 f3 v3 f4 v4 f5 v5;;

let todo b _ = string b "TODO";;

(*****************************************************************************)
(** Coq header *)

let header = "\
(**\n\
SimSoC-Cert, a toolkit for generating certified processor simulators\n\
See the COPYRIGHTS and LICENSE files.\n\
\n\
Coq representation of a C program automatically generated by Simgen.\n\
*)\n\
\n\
Require Import Coqlib Integers Floats AST Values Csyntax.\n\
\n\
Open Scope positive_scope.\n\
\n\
Notation \"[ ]\" := nil.\n\
Notation \"[ a ; .. ; b ]\" := (a :: .. (b :: nil) ..).\n\
\n\
Notation \"++\" := Signed.\n\
Notation \"--\" := Unsigned.\n\
\n\
Notation void := Tvoid.\n\
Notation int8 := (Tint I8 --).\n\
Notation uint8 := (Tint I8 ++).\n\
Notation int16 := (Tint I16 --).\n\
Notation uint16 := (Tint I16 ++).\n\
Notation int32 := (Tint I32 --).\n\
Notation uint32 := (Tint I32 ++).\n\
Notation float32 := (Tfloat F32).\n\
Notation float64 := (Tfloat F64).\n\
\n\
Notation \"`*\" := Tpointer.\n\
\n\
Notation \"a :T: b\" := (Tcons a b) (at level 70, right associativity).\n\
Notation \"T[ a ; .. ; b ]\" := (a :T: .. (b :T: Tnil) ..).\n\
\n\
Notation \"` x\" := (Int.repr x) (at level 9).\n\
\n\
Definition fcons a := Fcons (fst a) (snd a).\n\
Notation \"a :F: b\" := (fcons a b) (at level 70, right associativity).\n\
Notation \"F[ a ; .. ; b ]\" := (a :F: .. (b :F: Fnil) ..).\n\
\n\
Notation \"a `: b\" := (pair a b) (at level 60).\n\
\n\
Notation \"a ;; b\" := (Ssequence a b) (at level 9, right associativity).\n\
Notation \"'If' a 'then' b 'else' c\" := (Sifthenelse a b c) (at level 9).\n\
";;

(*****************************************************************************)
(** basic Coq data structures *)

let bool b = bprintf b "%b";;

let option elt b = function
  | None -> bprintf b "None"
  | Some x -> bprintf b "(Some %a)" elt x;;

let coq_list elt b = function
  | [] -> bprintf b "[]"
  | x :: l -> bprintf b "[%a%a]" elt x (list "" (prefix "; " elt)) l;;

let coq_pair f g b (Coq_pair (x, y)) = bprintf b "(%a,%a)" f x g y;;

let coq_Z b x = int32 b (camlint_of_z x);;

let int b x = int32 b (camlint_of_coqint x);;

let float = todo;;

(*****************************************************************************)
(** ident *)

let string_of_ident p =
  try Hashtbl.find string_of_atom p
  with Not_found -> assert false;;

let ident = using string_of_ident;;

(*****************************************************************************)
(** signature *)

let string_of_typ = function
  | AST.Tint -> "Tint"
  | AST.Tfloat -> "Tfloat";;

let typ = using string_of_typ;;

let signature b s =
  bprintf b "{| sig_args := %a; sig_res := %a |}"
    (coq_list typ) s.sig_args (option typ) s.sig_res;;

(*****************************************************************************)
(** type *)

let string_of_signedness = function
  | Signed -> "Signed"
  | Unsigned -> "Unsigned";;

let signedness = using string_of_signedness;;

let string_of_intsize = function
  | I8 -> "I8"
  | I16 -> "I16"
  | I32 -> "I32";;

let intsize = using string_of_intsize;;

let string_of_floatsize = function
  | F32 -> "F32"
  | F64 -> "F64";;

let floatsize = using string_of_floatsize;;

let rec types_of_typelist = function
  | Tnil -> []
  | Tcons (t, tl) -> t :: types_of_typelist tl;;

let rec fields_of_fieldlist = function
  | Fnil -> []
  | Fcons (id, t, fl) -> (id,t) :: fields_of_fieldlist fl;;

let rec coq_type b = function
  | Tvoid -> string b "void"
  | Tint (I8, Signed) -> string b "int8"
  | Tint (I8, Unsigned) -> string b "uint8"
  | Tint (I16, Signed) -> string b "int16"
  | Tint (I16, Unsigned) -> string b "uint16"
  | Tint (I32, Signed) -> string b "int32"
  | Tint (I32, Unsigned) -> string b "uint32"
  | Tfloat F32 -> string b "float32"
  | Tfloat F64 -> string b "float64"
  | Tpointer t -> papp1 b "`*" coq_type t
  | Tarray (t, n) -> papp2 b "Tarray" coq_type t coq_Z n
  | Tfunction (tl, t) -> papp2 b "Tfunction" typelist tl coq_type t
  | Tstruct (id, fl) -> papp2 b "Tstruct" ident id fieldlist fl
  | Tunion (id, fl) -> papp2 b "Tunion" ident id fieldlist fl
  | Tcomp_ptr id -> papp1 b "Tcomp_ptr" ident id

and typelist b tl = bprintf b "T%a" (coq_list coq_type) (types_of_typelist tl)

and fieldlist b fl = bprintf b "F%a" (coq_list field) (fields_of_fieldlist fl)

and field b = pair ident "`:" coq_type b;;

module TypOrd = struct
  type t = coq_type
  let compare = Pervasives.compare
end;;

module TypMap = Map.Make (TypOrd);;

let typTable = ref TypMap.empty;;

type kind = Union | Struct;;

let coq_type_of_kind k id fl =
  match k with
    | Union -> Tunion (id, fl)
    | Struct -> Tstruct (id, fl);;

let add_type k id fl =
  let t = coq_type_of_kind k id fl in
    try TypMap.find t !typTable
    with Not_found ->
      let s = string_of_ident id in
	typTable := TypMap.add t s !typTable;
	s;;
 
let rec coq_type_ref b = function
  | Tvoid -> string b "void"
  | Tint (I8, Signed) -> string b "int8"
  | Tint (I8, Unsigned) -> string b "uint8"
  | Tint (I16, Signed) -> string b "int16"
  | Tint (I16, Unsigned) -> string b "uint16"
  | Tint (I32, Signed) -> string b "int32"
  | Tint (I32, Unsigned) -> string b "uint32"
  | Tfloat F32 -> string b "float32"
  | Tfloat F64 -> string b "float64"
  | Tpointer t -> app1 b "`*" coq_type_ref t
  | Tarray (t, n) -> app2 b "Tarray" coq_type_ref t coq_Z n
  | Tfunction (tl, t) -> app2 b "Tfunction" typelist_ref tl coq_type_ref t
  | Tcomp_ptr id -> app1 b "Tcomp_ptr" ident id
  | Tstruct (id, fl) -> string b (add_type Struct id fl)
  | Tunion (id, fl) -> string b (add_type Union id fl)

and typelist_ref b tl =
  bprintf b "T%a" (coq_list coq_type_ref) (types_of_typelist tl)

and fieldlist_ref b fl =
  bprintf b "F%a" (coq_list field_ref) (fields_of_fieldlist fl)

and field_ref b = pair ident "`:" coq_type_ref b;;

let params = coq_list (coq_pair ident coq_type_ref);;

let types b _p = bprintf b "\n(* types *)\n\n";;

(*****************************************************************************)
(** expr *)

let unary_operation = todo;;

let binary_operation = todo;;

let block = coq_Z;;

let coq_val b = function
  | Vundef -> string b "Vundef"
  | Vint x -> papp1 b "Vint" int x
  | Vfloat x -> papp1 b "Vfloat" float x
  | Vptr (x, i) -> papp2 b "Vptr" block x int i;;

let rec exprs_of_exprlist = function
  | Enil -> []
  | Econs (e, el) -> e :: exprs_of_exprlist el;;

let string_of_incr_or_decr = function
  | Incr -> "Incr"
  | Decr -> "Decr";;

let incr_of_decr = using string_of_incr_or_decr;;

let rec expr b = function
  | Eval (v, t) -> papp2 b "Eval" coq_val v coq_type_ref t
  | Evar (id, t) -> papp2 b "Evar" ident id coq_type_ref t
  | Efield (e, id, t) -> papp3 b "Efield" expr e ident id coq_type_ref t
  | Evalof (e, t) -> papp2 b "Evalof" expr e coq_type_ref t
  | Ederef (e, t) -> papp2 b "Edered" expr e coq_type_ref t
  | Eaddrof (e, t) -> papp2 b "Eaddrof" expr e coq_type_ref t
  | Eunop (op, e, t) ->
      papp3 b "Eunop" unary_operation op expr e coq_type_ref t
  | Ebinop (op, e1, e2, t) ->
      papp4 b "Ebinop" binary_operation op expr e1 expr e2 coq_type_ref t
  | Ecast (e, t) -> papp2 b "Ecast" expr e coq_type_ref t
  | Econdition (e1, e2, e3, t) ->
      papp4 b "Econdition" expr e1 expr e2 expr e3 coq_type_ref t
  | Esizeof (t1, t2) -> papp2 b "Esizeof" coq_type_ref t1 coq_type_ref t2
  | Eassign (e1, e2, t) -> papp3 b "Eassign" expr e1 expr e2 coq_type_ref t
  | Eassignop (op, e1, e2, t1, t2) ->
      papp5 b "Eassignop" binary_operation op expr e1 expr e2
	coq_type_ref t1 coq_type_ref t2
  | Epostincr (id, e, t) ->
      papp3 b "Epostincr" incr_of_decr id expr e coq_type_ref t
  | Ecomma (e1, e2, t) -> papp3 b "Ecomma" expr e1 expr e2 coq_type_ref t
  | Ecall (e, el, t) -> papp3 b "Ecall" expr e exprlist el coq_type_ref t
  | Eloc (x, i, t) -> papp3 b "Eloc" block x int i coq_type_ref t
  | Eparen (e, t) -> papp2 b "Eparen" expr e coq_type_ref t

and exprlist b el = bprintf b "E%a" (coq_list expr) (exprs_of_exprlist el);;

(*****************************************************************************)
(** statement *)

let label = ident;;

let rec label_stats_of_labeled_statements = function
  | LSdefault s -> [None,s]
  | LScase (i, s, ls) -> (Some i,s) :: label_stats_of_labeled_statements ls;;

let rec statement b = function
  | Sskip -> string b "Sskip"
  | Sdo e -> papp1 b "Sdo" expr e
  | Ssequence (s1, s2) -> papp2 b "Ssequence" statement s1 statement s2
  | Sifthenelse (e, s1, s2) ->
      papp3 b "Sifthenelse" expr e statement s1 statement s2
  | Swhile (e, s) -> papp2 b "Swhile" expr e statement s
  | Sdowhile (e, s) -> papp2 b "Sdowhile" expr e statement s
  | Sfor (s1, e, s2, s3) ->
      papp4 b "Sfor" statement s1 expr e statement s2 statement s3
  | Sbreak -> string b "Sbreak"
  | Scontinue -> string b "Scontinue"
  | Sreturn oe -> papp1 b "Sreturn" (option expr) oe
  | Sswitch (e, ls) -> papp2 b "Sswitch" expr e labeled_statements ls
  | Slabel (l, s) -> papp2 b "Slabel" label l statement s
  | Sgoto l -> papp1 b "Sgoto" label l

and labeled_statements b ls =
  bprintf b "L%a" (coq_list label_stat) (label_stats_of_labeled_statements ls)

and label_stat b = function
  | None, s -> app1 b "LSdefault" statement s
  | Some i, s -> bprintf b "<%a: %a" int i statement s;;

(*****************************************************************************)
(** global variables *)

let prog_var_ref b (Coq_pair (id, _)) = bprintf b "var_%a" ident id;;

let prog_var_def b (Coq_pair (id, _gv)) =
  bprintf b "Definition var_%a := .\n" ident id;;

let variables b p =
  bprintf b "\n(* variables *)\n\n%a\n\nDefinition variables := %a.\n"
    (list_iter prog_var_def) p.prog_vars
    (coq_list prog_var_ref) p.prog_vars;;

(*****************************************************************************)
(** functions *)

let prog_funct_ref b (Coq_pair (id, _)) = bprintf b "fun_%a" ident id;;

let coq_function b f =
  bprintf b "{|\n  fn_return := %a;\n  fn_params := %a;\n  \
    fn_vars := %a;\n  fn_body := %a |}"
    coq_type f.fn_return params f.fn_params
    params f.fn_vars statement f.fn_body;;

let external_function b ef =
  bprintf b "{| ef_id := %a;\n ef_sig := %a;\n ef_inline := %a |}"
    ident ef.ef_id signature ef.ef_sig bool ef.ef_inline;;

let fundef b = function
  | Internal f -> bprintf b "(Internal %a)" coq_function f
  | External (ef, tl, t) -> bprintf b "(External %a %a %a)"
      external_function ef typelist tl coq_type t;;

let prog_funct_def b (Coq_pair (id, fd)) =
  bprintf b "Definition fun_%a := (%a, %a).\n\n" ident id ident id fundef fd;;

let functions b p =
  bprintf b "\n(* functions *)\n\n%a\n\nDefinition functions := %a.\n"
    (list_iter prog_funct_def) p.prog_funct
    (coq_list prog_funct_ref) p.prog_funct;;

(*****************************************************************************)
(** program *)

let program b p = bprintf b
  "\nDefinition program : AST.program fundef type :=\n  \
    {| prog_funct := functions;\n    \
       prog_main := %a;\n    \
       prog_vars := variables |}.\n" ident p.prog_main;;

(*****************************************************************************)
(** main printing function for Csyntax.program *)

let to_buffer p =
  let b = Buffer.create 10000 in
    bprintf b "%s%a%a%a%a" header types p variables p functions p program p;
    b;;
