(**
SimSoC-Cert, a toolkit for generating certified processor simulators
See the COPYRIGHTS and LICENSE files.

Pretty print CompCert type [AST.program fundef type] to Coq.
*)

open AST;;
open Values;;
open Csyntax;;
open Datatypes;;
open Printf;;
open Camlcoq;;

(*****************************************************************************)
(** basic OCaml data structures *)

type 'a bprint = Buffer.t -> 'a -> unit;;
type 'a fprint = out_channel -> 'a -> unit;;

let fprint f oc x =
  let b = Buffer.create 100 in
    f b x; fprintf oc "%s" (Buffer.contents b);;

let sprint f x =
  let b = Buffer.create 100 in
    f b x; sprintf "%s" (Buffer.contents b);;

let string b s = bprintf b "%s" s;;
let int b i = bprintf b "%d" i;;
let int32 b i = bprintf b "%ld" i;;

let pair f sep g b (x, y) = bprintf b "%a%s%a" f x sep g y;;
let first f b (x,_) = f b x;;
let second f b (_,x) = f b x;;

let par f b x = bprintf b "(%a)" f x;;

let prefix s f b x = bprintf b "%s%a" s f x;;
let postfix s f b x = bprintf b "%a%s" f x s;;
let endline f b x = postfix "\n" f b x;;

let list_iter elt b = List.iter (elt b);;

let list sep elt =
  let rec aux b = function
    | [] -> ()
    | [x] -> elt b x
    | x :: l -> bprintf b "%a%s%a" elt x sep aux l
  in aux;;

let list_nil nil sep elt =
  let rec aux b = function
    | [] -> bprintf b "%s" nil
    | x :: l -> bprintf b "%a%s%a" elt x sep aux l
  in aux;;

let plist f b = function
  | [] -> f b []
  | l -> par f b l;;

let using string_of_elt b x = string b (string_of_elt x);;

let app1 b s f1 v1 = bprintf b "%s %a" s f1 v1;;
let app2 b s f1 v1 f2 v2 = bprintf b "%s %a %a" s f1 v1 f2 v2;;
let app3 b s f1 v1 f2 v2 f3 v3 =
  bprintf b "%s %a %a %a" s f1 v1 f2 v2 f3 v3;;
let app4 b s f1 v1 f2 v2 f3 v3 f4 v4 =
  bprintf b "%s %a %a %a %a" s f1 v1 f2 v2 f3 v3 f4 v4;;
let papp5 b s f1 v1 f2 v2 f3 v3 f4 v4 f5 v5 =
  bprintf b "%s %a %a %a %a %a" s f1 v1 f2 v2 f3 v3 f4 v4 f5 v5;;

let papp1 b s f1 v1 = bprintf b "(%s %a)" s f1 v1;;
let papp2 b s f1 v1 f2 v2 = bprintf b "(%s %a %a)" s f1 v1 f2 v2;;
let papp3 b s f1 v1 f2 v2 f3 v3 =
  bprintf b "(%s %a %a %a)" s f1 v1 f2 v2 f3 v3;;
let papp4 b s f1 v1 f2 v2 f3 v3 f4 v4 =
  bprintf b "(%s %a %a %a %a)" s f1 v1 f2 v2 f3 v3 f4 v4;;
let papp5 b s f1 v1 f2 v2 f3 v3 f4 v4 f5 v5 =
  bprintf b "(%s %a %a %a %a %a)" s f1 v1 f2 v2 f3 v3 f4 v4 f5 v5;;

let todo b _ = string b "TODO";;

(*****************************************************************************)
(** Coq header *)

let header = "\
(**\n\
SimSoC-Cert, a toolkit for generating certified processor simulators\n\
See the COPYRIGHTS and LICENSE files.\n\
\n\
Coq representation of a C program automatically generated by Simgen.\n\
*)\n\
\n\
Require Import Coqlib Integers Floats AST Values Csyntax.\n\
\n\
Open Scope positive_scope.\n\
\n\
Notation \"[ ]\" := nil.\n\
Notation \"[ a ; .. ; b ]\" := (a :: .. (b :: nil) ..).\n\
\n\
Notation \"++\" := Signed.\n\
Notation \"--\" := Unsigned.\n\
\n\
Notation void := Tvoid.\n\
Notation int8 := (Tint I8 --).\n\
Notation uint8 := (Tint I8 ++).\n\
Notation int16 := (Tint I16 --).\n\
Notation uint16 := (Tint I16 ++).\n\
Notation int32 := (Tint I32 --).\n\
Notation uint32 := (Tint I32 ++).\n\
Notation float32 := (Tfloat F32).\n\
Notation float64 := (Tfloat F64).\n\
\n\
Notation \"`*\" := Tpointer.\n\
\n\
Notation \"a :T: b\" := (Tcons a b) (at level 70, right associativity).\n\
Notation \"T[ ]\" := Tnil.\n\
Notation \"T[ a ; .. ; b ]\" := (a :T: .. (b :T: Tnil) ..).\n\
\n\
Notation \"` x\" := (Int.repr x) (at level 9).\n\
\n\
Notation \"$ x\" := (Init_int8 (` x)) (at level 70).\n\
\n\
Definition fcons a := Fcons (fst a) (snd a).\n\
Notation \"a :F: b\" := (fcons a b) (at level 70, right associativity).\n\
Notation \"F[ ]\" := Fnil.\n\
Notation \"F[ a ; .. ; b ]\" := (a :F: .. (b :F: Fnil) ..).\n\
\n\
Notation \"a `: b\" := (pair a b) (at level 60).\n\
\n\
Notation \"a ;; b\" := (Ssequence a b) (at level 9, right associativity).\n\
Notation \"'If' a 'then' b 'else' c\" := (Sifthenelse a b c) (at level 9).\n\
";;

(*****************************************************************************)
(** basic Coq data structures *)

let bool b = bprintf b "%b";;

let option elt b = function
  | None -> bprintf b "None"
  | Some x -> bprintf b "Some %a" elt x;;

let coq_list elt b = function
  | [] -> bprintf b "[]"
  | x :: l -> bprintf b "[%a%a]" elt x (list "" (prefix "; " elt)) l;;

let coq_pair f g b (Coq_pair (x, y)) = bprintf b "(%a,%a)" f x g y;;

let coq_Z b x = int32 b (camlint_of_z x);;

let int b x = int32 b (camlint_of_coqint x);;

let positive b x = int32 b (camlint_of_positive x);;

let float = todo;;

let float32 = todo;;

let float64 = todo;;

(*****************************************************************************)
(** ident *)

let valid_coq_ident s =
  match s with
    | "end" as s -> "_" ^ s
    | _ ->
	for i = 0 to String.length s - 1 do
	  if s.[i] = '$' || s.[i] = ' ' then s.[i] <- '_'
	done;
	s;;

let identTable = Hashtbl.create 57;;

let add_ident id s = Hashtbl.add identTable id (valid_coq_ident s);;

let init_identTable () = Hashtbl.iter add_ident string_of_atom;;

let string_of_ident id =
  try Hashtbl.find identTable id
  with Not_found ->
    Printf.sprintf "unknown_atom_%ld" (camlint_of_positive id);;

let ident = using string_of_ident;;

let identifiers b =
  bprintf b "\n(* identifiers *)\n\n";
  Hashtbl.iter
    (fun id s -> bprintf b "Definition %s := %a.\n" s positive id)
    identTable;;

(*****************************************************************************)
(** signature *)

let string_of_typ = function
  | AST.Tint -> "AST.Tint"
  | AST.Tfloat -> "AST.Tfloat";;

let typ = using string_of_typ;;

let signature b s =
  bprintf b "{| sig_args := %a; sig_res := %a |}"
    (coq_list typ) s.sig_args (option typ) s.sig_res;;

(*****************************************************************************)
(** type *)

let string_of_signedness = function
  | Signed -> "Signed"
  | Unsigned -> "Unsigned";;

let signedness = using string_of_signedness;;

let string_of_intsize = function
  | I8 -> "I8"
  | I16 -> "I16"
  | I32 -> "I32";;

let intsize = using string_of_intsize;;

let string_of_floatsize = function
  | F32 -> "F32"
  | F64 -> "F64";;

let floatsize = using string_of_floatsize;;

let rec types_of_typelist = function
  | Tnil -> []
  | Tcons (t, tl) -> t :: types_of_typelist tl;;

let rec fields_of_fieldlist = function
  | Fnil -> []
  | Fcons (id, t, fl) -> (id,t) :: fields_of_fieldlist fl;;

let rec coq_type b = function
  | Tvoid -> string b "void"
  | Tint (I8, Signed) -> string b "int8"
  | Tint (I8, Unsigned) -> string b "uint8"
  | Tint (I16, Signed) -> string b "int16"
  | Tint (I16, Unsigned) -> string b "uint16"
  | Tint (I32, Signed) -> string b "int32"
  | Tint (I32, Unsigned) -> string b "uint32"
  | Tfloat F32 -> string b "float32"
  | Tfloat F64 -> string b "float64"
  | Tpointer t -> app1 b "`*" pcoq_type t
  | Tarray (t, n) -> app2 b "Tarray" pcoq_type t coq_Z n
  | Tfunction (tl, t) -> app2 b "Tfunction" typelist tl coq_type t
  | Tstruct (id, fl) -> app2 b "Tstruct" ident id fieldlist fl
  | Tunion (id, fl) -> app2 b "Tunion" ident id fieldlist fl
  | Tcomp_ptr id -> app1 b "Tcomp_ptr" ident id

and pcoq_type b t =
  match t with
  | Tvoid
  | Tint _
  | Tfloat _ -> coq_type b t
  | Tpointer _
  | Tarray _
  | Tfunction _
  | Tstruct _
  | Tunion _
  | Tcomp_ptr _ -> par coq_type b t

and typelist b tl = bprintf b "T%a" (coq_list coq_type) (types_of_typelist tl)

and fieldlist b fl = bprintf b "F%a" (coq_list field) (fields_of_fieldlist fl)

and field b = pair ident "`:" coq_type b;;

module TypOrd = struct
  type t = coq_type
  let compare = Pervasives.compare
end;;

module TypMap = Map.Make (TypOrd);;

let typTable = ref TypMap.empty;;

type kind = Union | Struct;;

let coq_type_of_kind k id fl =
  match k with
    | Union -> Tunion (id, fl)
    | Struct -> Tstruct (id, fl);;

let add_type k id fl =
  let t = coq_type_of_kind k id fl in
    try TypMap.find t !typTable
    with Not_found ->
      let s = string_of_ident id in
	typTable := TypMap.add t s !typTable;
	s;;
 
let rec coq_type_ref b t =
  match t with
    | Tvoid
    | Tint _
    | Tfloat _
    | Tpointer _
    | Tarray _
    | Tfunction _
    | Tcomp_ptr _ -> coq_type b t
    | Tstruct (id, fl) -> string b (add_type Struct id fl)
    | Tunion (id, fl) -> string b (add_type Union id fl)

and typelist_ref b tl =
  bprintf b "T%a" (coq_list coq_type_ref) (types_of_typelist tl)

and fieldlist_ref b fl =
  bprintf b "F%a" (coq_list field_ref) (fields_of_fieldlist fl)

and field_ref b = pair ident "`:" coq_type_ref b;;

let params = coq_list (coq_pair ident coq_type_ref);;

let types b _p = bprintf b "\n(* types *)\n\n";;

(*****************************************************************************)
(** expr *)

let string_of_unary_operation = function
  | Onotbool -> "Onotbool"
  | Onotint -> "Onotint"
  | Oneg -> "Oneg";;

let unary_operation = using string_of_unary_operation;;

let string_of_binary_operation = function
  | Oadd -> "Oadd"
  | Osub -> "Osub"
  | Omul -> "Omul"
  | Odiv -> "Odiv"
  | Omod -> "Omod"
  | Oand -> "Oand"
  | Oor -> "Oor"
  | Oxor -> "Oxor"
  | Oshl -> "Oshl"
  | Oshr -> "Oshr"
  | Oeq -> "Oeq"
  | One -> "One"
  | Olt -> "Olt"
  | Ogt -> "Ogt"
  | Ole -> "Ole"
  | Oge -> "Oge";;

let binary_operation = using string_of_binary_operation;;

let block = coq_Z;;

let coq_val b = function
  | Vundef -> string b "Vundef"
  | Vint x -> papp1 b "Vint" int x
  | Vfloat x -> papp1 b "Vfloat" float x
  | Vptr (x, i) -> papp2 b "Vptr" block x int i;;

let rec exprs_of_exprlist = function
  | Enil -> []
  | Econs (e, el) -> e :: exprs_of_exprlist el;;

let string_of_incr_or_decr = function
  | Incr -> "Incr"
  | Decr -> "Decr";;

let incr_of_decr = using string_of_incr_or_decr;;

let rec expr b = function
  | Eval (v, t) -> papp2 b "Eval" coq_val v coq_type_ref t
  | Evar (id, t) -> papp2 b "Evar" ident id coq_type_ref t
  | Efield (e, id, t) -> papp3 b "Efield" expr e ident id coq_type_ref t
  | Evalof (e, t) -> papp2 b "Evalof" expr e coq_type_ref t
  | Ederef (e, t) -> papp2 b "Ederef" expr e coq_type_ref t
  | Eaddrof (e, t) -> papp2 b "Eaddrof" expr e coq_type_ref t
  | Eunop (op, e, t) ->
      papp3 b "Eunop" unary_operation op expr e coq_type_ref t
  | Ebinop (op, e1, e2, t) ->
      papp4 b "Ebinop" binary_operation op expr e1 expr e2 coq_type_ref t
  | Ecast (e, t) -> papp2 b "Ecast" expr e coq_type_ref t
  | Econdition (e1, e2, e3, t) ->
      papp4 b "Econdition" expr e1 expr e2 expr e3 coq_type_ref t
  | Esizeof (t1, t2) -> papp2 b "Esizeof" coq_type_ref t1 coq_type_ref t2
  | Eassign (e1, e2, t) -> papp3 b "Eassign" expr e1 expr e2 coq_type_ref t
  | Eassignop (op, e1, e2, t1, t2) ->
      papp5 b "Eassignop" binary_operation op expr e1 expr e2
	coq_type_ref t1 coq_type_ref t2
  | Epostincr (id, e, t) ->
      papp3 b "Epostincr" incr_of_decr id expr e coq_type_ref t
  | Ecomma (e1, e2, t) -> papp3 b "Ecomma" expr e1 expr e2 coq_type_ref t
  | Ecall (e, el, t) -> papp3 b "Ecall" expr e exprlist el coq_type_ref t
  | Eloc (x, i, t) -> papp3 b "Eloc" block x int i coq_type_ref t
  | Eparen (e, t) -> papp2 b "Eparen" expr e coq_type_ref t

and exprlist b el = bprintf b "E%a" (coq_list expr) (exprs_of_exprlist el);;

(*****************************************************************************)
(** statement *)

let label = ident;;

let rec label_stats_of_labeled_statements = function
  | LSdefault s -> [None,s]
  | LScase (i, s, ls) -> (Some i,s) :: label_stats_of_labeled_statements ls;;

let rec statement b = function
  | Sskip -> string b "Sskip"
  | Sdo e -> papp1 b "Sdo" expr e
  | Ssequence (s1, s2) -> papp2 b "Ssequence" statement s1 statement s2
  | Sifthenelse (e, s1, s2) ->
      papp3 b "Sifthenelse" expr e statement s1 statement s2
  | Swhile (e, s) -> papp2 b "Swhile" expr e statement s
  | Sdowhile (e, s) -> papp2 b "Sdowhile" expr e statement s
  | Sfor (s1, e, s2, s3) ->
      papp4 b "Sfor" statement s1 expr e statement s2 statement s3
  | Sbreak -> string b "Sbreak"
  | Scontinue -> string b "Scontinue"
  | Sreturn oe -> papp1 b "Sreturn" (par (option expr)) oe
  | Sswitch (e, ls) -> papp2 b "Sswitch" expr e labeled_statements ls
  | Slabel (l, s) -> papp2 b "Slabel" label l statement s
  | Sgoto l -> papp1 b "Sgoto" label l

and labeled_statements b ls =
  bprintf b "L%a" (coq_list label_stat) (label_stats_of_labeled_statements ls)

and label_stat b = function
  | None, s -> app1 b "LSdefault" statement s
  | Some i, s -> bprintf b "<%a: %a" int i statement s;;

(*****************************************************************************)
(** global variables *)

let prog_var_ref b (Coq_pair (id, _)) = bprintf b "gv_%a" ident id;;

let init_data b = function
  | Init_int8 x -> bprintf b "$%a" int x
  | Init_int16 x -> app1 b "Init_int16" int x
  | Init_int32 x -> app1 b "Init_int32" int x
  | Init_float32 x -> app1 b "Init_float32" float32 x
  | Init_float64 x -> app1 b "Init_float64" float64 x
  | Init_space x -> app1 b "Init_space" coq_Z x
  | Init_addrof (id, x) -> app2 b "Init_addrof" ident id int x;;

let gvar_init = coq_list init_data;;

let prog_var_def b (Coq_pair (id, v)) =
  bprintf b "Definition gv_%a :=\n  {| gvar_info := %a;\n     \
    gvar_init := %a;\n     gvar_readonly := %a;\n     \
    gvar_volatile := %a |}.\n\n" ident id coq_type v.gvar_info
    gvar_init v.gvar_init bool v.gvar_readonly bool v.gvar_volatile;;

let global_variables b p =
  bprintf b "\n(* global variables *)\n\n%a\n\n\
    Definition global_variables := %a.\n"
    (list_iter prog_var_def) p.prog_vars
    (coq_list prog_var_ref) p.prog_vars;;

(*****************************************************************************)
(** functions *)

let prog_funct_ref b (Coq_pair (id, _)) = bprintf b "fun_%a" ident id;;

let coq_function b f =
  bprintf b "{| fn_return := %a;\n     fn_params := %a;\n     \
    fn_vars := %a;\n     fn_body := %a |}"
    coq_type f.fn_return params f.fn_params
    params f.fn_vars statement f.fn_body;;

let external_function b ef =
  bprintf b "{| ef_id := %a;\n     ef_sig := %a;\n     ef_inline := %a |}"
    ident ef.ef_id signature ef.ef_sig bool ef.ef_inline;;

let fundef b = function
  | Internal f -> bprintf b "Internal\n  %a" coq_function f
  | External (ef, tl, t) -> bprintf b "External\n  %a\n  %a\n  %a"
      external_function ef typelist tl pcoq_type t;;

let prog_funct_def b (Coq_pair (id, fd)) =
  bprintf b "Definition fun_%a := (%a, %a).\n\n" ident id ident id fundef fd;;

let functions b p =
  bprintf b "\n(* functions *)\n\n%a\n\nDefinition functions := %a.\n"
    (list_iter prog_funct_def) p.prog_funct
    (coq_list prog_funct_ref) p.prog_funct;;

(*****************************************************************************)
(** program *)

let program b p = bprintf b
  "\nDefinition program : AST.program fundef type :=\n  \
    {| prog_funct := functions;\n    \
       prog_main := %a;\n    \
       prog_vars := global_variables |}.\n" ident p.prog_main;;

(*****************************************************************************)
(** main printing function for Csyntax.program *)

let to_buffer p =
  let b = Buffer.create 10000 in
    init_identTable ();
    string b header;
    identifiers b;
    types b p;
    global_variables b p;
    functions b p;
    program b p;
    b;;
